(function(g,f){typeof exports==='object'&&typeof module!=='undefined'?f(exports):typeof define==='function'&&define.amd?define(['exports'],f):(g=typeof globalThis!=='undefined'?globalThis:g||self,f(g.jose={}));})(this,(function(exports){'use strict';var ir=Object.defineProperty;var wt=(e,t)=>{for(var r in t)ir(e,r,{get:t[r],enumerable:true});};var Fe={};wt(Fe,{decode:()=>y,encode:()=>w});var z=new TextEncoder,C=new TextDecoder,ve=2**32;function x(...e){let t=e.reduce((o,{length:i})=>o+i,0),r=new Uint8Array(t),n=0;for(let o of e)r.set(o,n),n+=o.length;return r}function Ve(e,t,r){if(t<0||t>=ve)throw new RangeError(`value must be >= 0 and <= ${ve-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,t&255],r);}function He(e){let t=Math.floor(e/ve),r=e%ve,n=new Uint8Array(8);return Ve(n,t,0),Ve(n,r,4),n}function Je(e){let t=new Uint8Array(4);return Ve(t,e),t}function E(e){let t=new Uint8Array(e.length);for(let r=0;r<e.length;r++){let n=e.charCodeAt(r);if(n>127)throw new TypeError("non-ASCII string encountered in encode()");t[r]=n;}return t}function he(e){if(Uint8Array.prototype.toBase64)return e.toBase64();let t=32768,r=[];for(let n=0;n<e.length;n+=t)r.push(String.fromCharCode.apply(null,e.subarray(n,n+t)));return btoa(r.join(""))}function Ie(e){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(e);let t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r}function y(e){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(typeof e=="string"?e:C.decode(e),{alphabet:"base64url"});let t=e;t instanceof Uint8Array&&(t=C.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/");try{return Ie(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}}function w(e){let t=e;return typeof t=="string"&&(t=z.encode(t)),Uint8Array.prototype.toBase64?t.toBase64({alphabet:"base64url",omitPadding:true}):he(t).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}var St={};wt(St,{JOSEAlgNotAllowed:()=>$,JOSEError:()=>K,JOSENotSupported:()=>h,JWEDecryptionFailed:()=>B,JWEInvalid:()=>c,JWKInvalid:()=>ue,JWKSInvalid:()=>ae,JWKSMultipleMatchingKeys:()=>me,JWKSNoMatchingKey:()=>X,JWKSTimeout:()=>le,JWSInvalid:()=>m,JWSSignatureVerificationFailed:()=>Y,JWTClaimValidationFailed:()=>P,JWTExpired:()=>ie,JWTInvalid:()=>g});var K=class extends Error{static code="ERR_JOSE_GENERIC";code="ERR_JOSE_GENERIC";constructor(t,r){super(t,r),this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor);}},P=class extends K{static code="ERR_JWT_CLAIM_VALIDATION_FAILED";code="ERR_JWT_CLAIM_VALIDATION_FAILED";claim;reason;payload;constructor(t,r,n="unspecified",o="unspecified"){super(t,{cause:{claim:n,reason:o,payload:r}}),this.claim=n,this.reason=o,this.payload=r;}},ie=class extends K{static code="ERR_JWT_EXPIRED";code="ERR_JWT_EXPIRED";claim;reason;payload;constructor(t,r,n="unspecified",o="unspecified"){super(t,{cause:{claim:n,reason:o,payload:r}}),this.claim=n,this.reason=o,this.payload=r;}},$=class extends K{static code="ERR_JOSE_ALG_NOT_ALLOWED";code="ERR_JOSE_ALG_NOT_ALLOWED"},h=class extends K{static code="ERR_JOSE_NOT_SUPPORTED";code="ERR_JOSE_NOT_SUPPORTED"},B=class extends K{static code="ERR_JWE_DECRYPTION_FAILED";code="ERR_JWE_DECRYPTION_FAILED";constructor(t="decryption operation failed",r){super(t,r);}},c=class extends K{static code="ERR_JWE_INVALID";code="ERR_JWE_INVALID"},m=class extends K{static code="ERR_JWS_INVALID";code="ERR_JWS_INVALID"},g=class extends K{static code="ERR_JWT_INVALID";code="ERR_JWT_INVALID"},ue=class extends K{static code="ERR_JWK_INVALID";code="ERR_JWK_INVALID"},ae=class extends K{static code="ERR_JWKS_INVALID";code="ERR_JWKS_INVALID"},X=class extends K{static code="ERR_JWKS_NO_MATCHING_KEY";code="ERR_JWKS_NO_MATCHING_KEY";constructor(t="no applicable key found in the JSON Web Key Set",r){super(t,r);}},me=class extends K{[Symbol.asyncIterator];static code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";constructor(t="multiple matching keys found in the JSON Web Key Set",r){super(t,r);}},le=class extends K{static code="ERR_JWKS_TIMEOUT";code="ERR_JWKS_TIMEOUT";constructor(t="request timed out",r){super(t,r);}},Y=class extends K{static code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";constructor(t="signature verification failed",r){super(t,r);}};function ze(e){switch(e){case "A128GCM":case "A128GCMKW":case "A192GCM":case "A192GCMKW":case "A256GCM":case "A256GCMKW":return 96;case "A128CBC-HS256":case "A192CBC-HS384":case "A256CBC-HS512":return 128;default:throw new h(`Unsupported JWE Algorithm: ${e}`)}}var Et=e=>crypto.getRandomValues(new Uint8Array(ze(e)>>3));function Te(e,t){if(t.length<<3!==ze(e))throw new c("Invalid Initialization Vector length")}function se(e,t){let r=e.byteLength<<3;if(r!==t)throw new c(`Invalid Content Encryption Key length. Expected ${t} bits, got ${r} bits`)}var W=(e,t="algorithm.name")=>new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`),O=(e,t)=>e.name===t;function Re(e){return parseInt(e.name.slice(4),10)}function ar(e){switch(e){case "ES256":return "P-256";case "ES384":return "P-384";case "ES512":return "P-521";default:throw new Error("unreachable")}}function At(e,t){if(t&&!e.usages.includes(t))throw new TypeError(`CryptoKey does not support this operation, its usages must include ${t}.`)}function gt(e,t,r){switch(t){case "HS256":case "HS384":case "HS512":{if(!O(e.algorithm,"HMAC"))throw W("HMAC");let n=parseInt(t.slice(2),10);if(Re(e.algorithm.hash)!==n)throw W(`SHA-${n}`,"algorithm.hash");break}case "RS256":case "RS384":case "RS512":{if(!O(e.algorithm,"RSASSA-PKCS1-v1_5"))throw W("RSASSA-PKCS1-v1_5");let n=parseInt(t.slice(2),10);if(Re(e.algorithm.hash)!==n)throw W(`SHA-${n}`,"algorithm.hash");break}case "PS256":case "PS384":case "PS512":{if(!O(e.algorithm,"RSA-PSS"))throw W("RSA-PSS");let n=parseInt(t.slice(2),10);if(Re(e.algorithm.hash)!==n)throw W(`SHA-${n}`,"algorithm.hash");break}case "Ed25519":case "EdDSA":{if(!O(e.algorithm,"Ed25519"))throw W("Ed25519");break}case "ML-DSA-44":case "ML-DSA-65":case "ML-DSA-87":{if(!O(e.algorithm,t))throw W(t);break}case "ES256":case "ES384":case "ES512":{if(!O(e.algorithm,"ECDSA"))throw W("ECDSA");let n=ar(t);if(e.algorithm.namedCurve!==n)throw W(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}At(e,r);}function J(e,t,r){switch(t){case "A128GCM":case "A192GCM":case "A256GCM":{if(!O(e.algorithm,"AES-GCM"))throw W("AES-GCM");let n=parseInt(t.slice(1,4),10);if(e.algorithm.length!==n)throw W(n,"algorithm.length");break}case "A128KW":case "A192KW":case "A256KW":{if(!O(e.algorithm,"AES-KW"))throw W("AES-KW");let n=parseInt(t.slice(1,4),10);if(e.algorithm.length!==n)throw W(n,"algorithm.length");break}case "ECDH":{switch(e.algorithm.name){case "ECDH":case "X25519":break;default:throw W("ECDH or X25519")}break}case "PBES2-HS256+A128KW":case "PBES2-HS384+A192KW":case "PBES2-HS512+A256KW":if(!O(e.algorithm,"PBKDF2"))throw W("PBKDF2");break;case "RSA-OAEP":case "RSA-OAEP-256":case "RSA-OAEP-384":case "RSA-OAEP-512":{if(!O(e.algorithm,"RSA-OAEP"))throw W("RSA-OAEP");let n=parseInt(t.slice(9),10)||1;if(Re(e.algorithm.hash)!==n)throw W(`SHA-${n}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}At(e,r);}function bt(e,t,...r){if(r=r.filter(Boolean),r.length>2){let n=r.pop();e+=`one of type ${r.join(", ")}, or ${n}.`;}else r.length===2?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return t==null?e+=` Received ${t}`:typeof t=="function"&&t.name?e+=` Received function ${t.name}`:typeof t=="object"&&t!=null&&t.constructor?.name&&(e+=` Received an instance of ${t.constructor.name}`),e}var I=(e,...t)=>bt("Key must be ",e,...t),Xe=(e,t,...r)=>bt(`Key for the ${e} algorithm must be `,t,...r);function q(e){if(!T(e))throw new Error("CryptoKey instance expected")}var T=e=>{if(e?.[Symbol.toStringTag]==="CryptoKey")return  true;try{return e instanceof CryptoKey}catch{return  false}},Q=e=>e?.[Symbol.toStringTag]==="KeyObject",ye=e=>T(e)||Q(e);async function sr(e,t){if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");let r={name:"HMAC",hash:"SHA-256"},n=await crypto.subtle.generateKey(r,false,["sign"]),o=new Uint8Array(await crypto.subtle.sign(r,n,e)),i=new Uint8Array(await crypto.subtle.sign(r,n,t)),a=0,s=-1;for(;++s<32;)a|=o[s]^i[s];return a===0}async function cr(e,t,r,n,o,i){if(!(t instanceof Uint8Array))throw new TypeError(I(t,"Uint8Array"));let a=parseInt(e.slice(1,4),10),s=await crypto.subtle.importKey("raw",t.subarray(a>>3),"AES-CBC",false,["decrypt"]),d=await crypto.subtle.importKey("raw",t.subarray(0,a>>3),{hash:`SHA-${a<<1}`,name:"HMAC"},false,["sign"]),p=x(i,n,r,He(i.length<<3)),f=new Uint8Array((await crypto.subtle.sign("HMAC",d,p)).slice(0,a>>3)),u;try{u=await sr(o,f);}catch{}if(!u)throw new B;let b;try{b=new Uint8Array(await crypto.subtle.decrypt({iv:n,name:"AES-CBC"},s,r));}catch{}if(!b)throw new B;return b}async function pr(e,t,r,n,o,i){let a;t instanceof Uint8Array?a=await crypto.subtle.importKey("raw",t,"AES-GCM",false,["decrypt"]):(J(t,e,"decrypt"),a=t);try{return new Uint8Array(await crypto.subtle.decrypt({additionalData:i,iv:n,name:"AES-GCM",tagLength:128},a,x(r,o)))}catch{throw new B}}async function De(e,t,r,n,o,i){if(!T(t)&&!(t instanceof Uint8Array))throw new TypeError(I(t,"CryptoKey","KeyObject","Uint8Array","JSON Web Key"));if(!n)throw new c("JWE Initialization Vector missing");if(!o)throw new c("JWE Authentication Tag missing");switch(Te(e,n),e){case "A128CBC-HS256":case "A192CBC-HS384":case "A256CBC-HS512":return t instanceof Uint8Array&&se(t,parseInt(e.slice(-3),10)),cr(e,t,r,n,o,i);case "A128GCM":case "A192GCM":case "A256GCM":return t instanceof Uint8Array&&se(t,parseInt(e.slice(1,4),10)),pr(e,t,r,n,o,i);default:throw new h("Unsupported JWE Content Encryption Algorithm")}}function U(...e){let t=e.filter(Boolean);if(t.length===0||t.length===1)return  true;let r;for(let n of t){let o=Object.keys(n);if(!r||r.size===0){r=new Set(o);continue}for(let i of o){if(r.has(i))return  false;r.add(i);}}return  true}var dr=e=>typeof e=="object"&&e!==null;function l(e){if(!dr(e)||Object.prototype.toString.call(e)!=="[object Object]")return  false;if(Object.getPrototypeOf(e)===null)return  true;let t=e;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}function Kt(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function Ct(e,t,r){return e instanceof Uint8Array?crypto.subtle.importKey("raw",e,"AES-KW",true,[r]):(J(e,t,r),e)}async function we(e,t,r){let n=await Ct(t,e,"wrapKey");Kt(n,e);let o=await crypto.subtle.importKey("raw",r,{hash:"SHA-256",name:"HMAC"},true,["sign"]);return new Uint8Array(await crypto.subtle.wrapKey("raw",o,n,"AES-KW"))}async function Se(e,t,r){let n=await Ct(t,e,"unwrapKey");Kt(n,e);let o=await crypto.subtle.unwrapKey("raw",r,n,"AES-KW",{hash:"SHA-256",name:"HMAC"},true,["sign"]);return new Uint8Array(await crypto.subtle.exportKey("raw",o))}async function Oe(e,t){let r=`SHA-${e.slice(-3)}`;return new Uint8Array(await crypto.subtle.digest(r,t))}function qe(e){return x(Je(e.length),e)}async function fr(e,t,r){let n=t>>3,o=32,i=Math.ceil(n/o),a=new Uint8Array(i*o);for(let s=1;s<=i;s++){let d=new Uint8Array(4+e.length+r.length);d.set(Je(s),0),d.set(e,4),d.set(r,4+e.length);let p=await Oe("sha256",d);a.set(p,(s-1)*o);}return a.slice(0,n)}async function Ue(e,t,r,n,o=new Uint8Array,i=new Uint8Array){J(e,"ECDH"),J(t,"ECDH","deriveBits");let a=qe(E(r)),s=qe(o),d=qe(i),p=Je(n),f=new Uint8Array,u=x(a,s,d,p,f),b=new Uint8Array(await crypto.subtle.deriveBits({name:e.algorithm.name,public:e},t,hr(e)));return fr(b,n,u)}function hr(e){return e.algorithm.name==="X25519"?256:Math.ceil(parseInt(e.algorithm.namedCurve.slice(-3),10)/8)<<3}function Me(e){switch(e.algorithm.namedCurve){case "P-256":case "P-384":case "P-521":return  true;default:return e.algorithm.name==="X25519"}}function ur(e,t){return e instanceof Uint8Array?crypto.subtle.importKey("raw",e,"PBKDF2",false,["deriveBits"]):(J(e,t,"deriveBits"),e)}var mr=(e,t)=>x(E(e),Uint8Array.of(0),t);async function Pt(e,t,r,n){if(!(e instanceof Uint8Array)||e.length<8)throw new c("PBES2 Salt Input must be 8 or more octets");let o=mr(t,e),i=parseInt(t.slice(13,16),10),a={hash:`SHA-${t.slice(8,11)}`,iterations:r,name:"PBKDF2",salt:o},s=await ur(n,t);return new Uint8Array(await crypto.subtle.deriveBits(a,s,i))}async function Wt(e,t,r,n=2048,o=crypto.getRandomValues(new Uint8Array(16))){let i=await Pt(o,e,n,t);return {encryptedKey:await we(e.slice(-6),i,r),p2c:n,p2s:w(o)}}async function vt(e,t,r,n,o){let i=await Pt(o,e,n,t);return Se(e.slice(-6),i,r)}function Z(e,t){if(e.startsWith("RS")||e.startsWith("PS")){let{modulusLength:r}=t.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}}var Jt=e=>{switch(e){case "RSA-OAEP":case "RSA-OAEP-256":case "RSA-OAEP-384":case "RSA-OAEP-512":return "RSA-OAEP";default:throw new h(`alg ${e} is not supported either by JOSE or your javascript runtime`)}};async function It(e,t,r){return J(t,e,"encrypt"),Z(e,t),new Uint8Array(await crypto.subtle.encrypt(Jt(e),t,r))}async function Tt(e,t,r){return J(t,e,"decrypt"),Z(e,t),new Uint8Array(await crypto.subtle.decrypt(Jt(e),t,r))}function Ee(e){switch(e){case "A128GCM":return 128;case "A192GCM":return 192;case "A256GCM":case "A128CBC-HS256":return 256;case "A192CBC-HS384":return 384;case "A256CBC-HS512":return 512;default:throw new h(`Unsupported JWE Algorithm: ${e}`)}}var M=e=>crypto.getRandomValues(new Uint8Array(Ee(e)>>3));var Dt=(e,t)=>{let r=(e.match(/.{1,64}/g)||[]).join(`
`);return `-----BEGIN ${t}-----
${r}
-----END ${t}-----`},Ot=async(e,t,r)=>{if(Q(r)){if(r.type!==e)throw new TypeError(`key is not a ${e} key`);return r.export({format:"pem",type:t})}if(!T(r))throw new TypeError(I(r,"CryptoKey","KeyObject"));if(!r.extractable)throw new TypeError("CryptoKey is not extractable");if(r.type!==e)throw new TypeError(`key is not a ${e} key`);return Dt(he(new Uint8Array(await crypto.subtle.exportKey(t,r))),`${e.toUpperCase()} KEY`)},Ut=e=>Ot("public","spki",e),Mt=e=>Ot("private","pkcs8",e),Qe=(e,t)=>{if(e.byteLength!==t.length)return  false;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return  false;return  true},je=e=>({data:e,pos:0}),D=e=>{let t=e.data[e.pos++];if(t&128){let r=t&127,n=0;for(let o=0;o<r;o++)n=n<<8|e.data[e.pos++];return n}return t},Ze=(e,t=1)=>{if(t<=0)return;e.pos++;let r=D(e);e.pos+=r,t>1&&Ze(e,t-1);},k=(e,t,r)=>{if(e.data[e.pos++]!==t)throw new Error(r)},kt=(e,t)=>{let r=e.data.subarray(e.pos,e.pos+t);return e.pos+=t,r},lr=e=>{k(e,6,"Expected algorithm OID");let t=D(e);return kt(e,t)};function yr(e){k(e,48,"Invalid PKCS#8 structure"),D(e),k(e,2,"Expected version field");let t=D(e);e.pos+=t,k(e,48,"Expected algorithm identifier");let r=D(e);return {algIdStart:e.pos,algIdLength:r}}function wr(e){k(e,48,"Invalid SPKI structure"),D(e),k(e,48,"Expected algorithm identifier");let t=D(e);return {algIdStart:e.pos,algIdLength:t}}var _t=e=>{let t=lr(e);if(Qe(t,[43,101,110]))return "X25519";if(!Qe(t,[42,134,72,206,61,2,1]))throw new Error("Unsupported key algorithm");k(e,6,"Expected curve OID");let r=D(e),n=kt(e,r);for(let{name:o,oid:i}of [{name:"P-256",oid:[42,134,72,206,61,3,1,7]},{name:"P-384",oid:[43,129,4,0,34]},{name:"P-521",oid:[43,129,4,0,35]}])if(Qe(n,i))return o;throw new Error("Unsupported named curve")},Nt=async(e,t,r,n)=>{let o,i,a=e==="spki",s=()=>a?["verify"]:["sign"],d=()=>a?["encrypt","wrapKey"]:["decrypt","unwrapKey"];switch(r){case "PS256":case "PS384":case "PS512":o={name:"RSA-PSS",hash:`SHA-${r.slice(-3)}`},i=s();break;case "RS256":case "RS384":case "RS512":o={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${r.slice(-3)}`},i=s();break;case "RSA-OAEP":case "RSA-OAEP-256":case "RSA-OAEP-384":case "RSA-OAEP-512":o={name:"RSA-OAEP",hash:`SHA-${parseInt(r.slice(-3),10)||1}`},i=d();break;case "ES256":case "ES384":case "ES512":{o={name:"ECDSA",namedCurve:{ES256:"P-256",ES384:"P-384",ES512:"P-521"}[r]},i=s();break}case "ECDH-ES":case "ECDH-ES+A128KW":case "ECDH-ES+A192KW":case "ECDH-ES+A256KW":{try{let p=n.getNamedCurve(t);o=p==="X25519"?{name:"X25519"}:{name:"ECDH",namedCurve:p};}catch{throw new h("Invalid or unsupported key format")}i=a?[]:["deriveBits"];break}case "Ed25519":case "EdDSA":o={name:"Ed25519"},i=s();break;case "ML-DSA-44":case "ML-DSA-65":case "ML-DSA-87":o={name:r},i=s();break;default:throw new h('Invalid or unsupported "alg" (Algorithm) value')}return crypto.subtle.importKey(e,t,o,n?.extractable??!!a,i)},et=(e,t)=>Ie(e.replace(t,"")),Lt=(e,t,r)=>{let n=et(e,/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g),o=r;return t?.startsWith?.("ECDH-ES")&&(o||={},o.getNamedCurve=i=>{let a=je(i);return yr(a),_t(a)}),Nt("pkcs8",n,t,o)},tt=(e,t,r)=>{let n=et(e,/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g),o=r;return t?.startsWith?.("ECDH-ES")&&(o||={},o.getNamedCurve=i=>{let a=je(i);return wr(a),_t(a)}),Nt("spki",n,t,o)};function Sr(e){let t=je(e);k(t,48,"Invalid certificate structure"),D(t),k(t,48,"Invalid tbsCertificate structure"),D(t),e[t.pos]===160?Ze(t,6):Ze(t,5);let r=t.pos;k(t,48,"Invalid SPKI structure");let n=D(t);return e.subarray(r,r+n+(t.pos-r))}function Er(e){let t=et(e,/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g);return Sr(t)}var Bt=(e,t,r)=>{let n;try{n=Er(e);}catch(o){throw new TypeError("Failed to parse the X.509 certificate",{cause:o})}return tt(Dt(he(n),"PUBLIC KEY"),t,r)};function Ar(e){let t,r;switch(e.kty){case "AKP":{switch(e.alg){case "ML-DSA-44":case "ML-DSA-65":case "ML-DSA-87":t={name:e.alg},r=e.priv?["sign"]:["verify"];break;default:throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case "RSA":{switch(e.alg){case "PS256":case "PS384":case "PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case "RS256":case "RS384":case "RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case "RSA-OAEP":case "RSA-OAEP-256":case "RSA-OAEP-384":case "RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case "EC":{switch(e.alg){case "ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case "ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case "ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case "ECDH-ES":case "ECDH-ES+A128KW":case "ECDH-ES+A192KW":case "ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case "OKP":{switch(e.alg){case "Ed25519":case "EdDSA":t={name:"Ed25519"},r=e.d?["sign"]:["verify"];break;case "ECDH-ES":case "ECDH-ES+A128KW":case "ECDH-ES+A192KW":case "ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new h('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return {algorithm:t,keyUsages:r}}async function ce(e){if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');let{algorithm:t,keyUsages:r}=Ar(e),n={...e};return n.kty!=="AKP"&&delete n.alg,delete n.use,crypto.subtle.importKey("jwk",n,t,e.ext??!(e.d||e.priv),e.key_ops??r)}async function gr(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN PUBLIC KEY-----")!==0)throw new TypeError('"spki" must be SPKI formatted string');return tt(e,t,r)}async function br(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN CERTIFICATE-----")!==0)throw new TypeError('"x509" must be X.509 formatted string');return Bt(e,t,r)}async function Kr(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN PRIVATE KEY-----")!==0)throw new TypeError('"pkcs8" must be PKCS#8 formatted string');return Lt(e,t,r)}async function j(e,t,r){if(!l(e))throw new TypeError("JWK must be an object");let n;switch(t??=e.alg,n??=r?.extractable??e.ext,e.kty){case "oct":if(typeof e.k!="string"||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return y(e.k);case "RSA":if("oth"in e&&e.oth!==void 0)throw new h('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');return ce({...e,alg:t,ext:n});case "AKP":{if(typeof e.alg!="string"||!e.alg)throw new TypeError('missing "alg" (Algorithm) Parameter value');if(t!==void 0&&t!==e.alg)throw new TypeError("JWK alg and alg option value mismatch");return ce({...e,ext:n})}case "EC":case "OKP":return ce({...e,alg:t,ext:n});default:throw new h('Unsupported "kty" (Key Type) Parameter value')}}async function Cr(e,t,r,n,o){if(!(r instanceof Uint8Array))throw new TypeError(I(r,"Uint8Array"));let i=parseInt(e.slice(1,4),10),a=await crypto.subtle.importKey("raw",r.subarray(i>>3),"AES-CBC",false,["encrypt"]),s=await crypto.subtle.importKey("raw",r.subarray(0,i>>3),{hash:`SHA-${i<<1}`,name:"HMAC"},false,["sign"]),d=new Uint8Array(await crypto.subtle.encrypt({iv:n,name:"AES-CBC"},a,t)),p=x(o,n,d,He(o.length<<3)),f=new Uint8Array((await crypto.subtle.sign("HMAC",s,p)).slice(0,i>>3));return {ciphertext:d,tag:f,iv:n}}async function xr(e,t,r,n,o){let i;r instanceof Uint8Array?i=await crypto.subtle.importKey("raw",r,"AES-GCM",false,["encrypt"]):(J(r,e,"encrypt"),i=r);let a=new Uint8Array(await crypto.subtle.encrypt({additionalData:o,iv:n,name:"AES-GCM",tagLength:128},i,t)),s=a.slice(-16);return {ciphertext:a.slice(0,-16),tag:s,iv:n}}async function ke(e,t,r,n,o){if(!T(r)&&!(r instanceof Uint8Array))throw new TypeError(I(r,"CryptoKey","KeyObject","Uint8Array","JSON Web Key"));switch(n?Te(e,n):n=Et(e),e){case "A128CBC-HS256":case "A192CBC-HS384":case "A256CBC-HS512":return r instanceof Uint8Array&&se(r,parseInt(e.slice(-3),10)),Cr(e,t,r,n,o);case "A128GCM":case "A192GCM":case "A256GCM":return r instanceof Uint8Array&&se(r,parseInt(e.slice(1,4),10)),xr(e,t,r,n,o);default:throw new h("Unsupported JWE Content Encryption Algorithm")}}async function $t(e,t,r,n){let o=e.slice(0,7),i=await ke(o,r,t,n,new Uint8Array);return {encryptedKey:i.ciphertext,iv:w(i.iv),tag:w(i.tag)}}async function Gt(e,t,r,n,o){let i=e.slice(0,7);return De(i,t,r,n,o,new Uint8Array)}async function Vt(e,t,r,n,o){switch(e){case "dir":{if(r!==void 0)throw new c("Encountered unexpected JWE Encrypted Key");return t}case "ECDH-ES":if(r!==void 0)throw new c("Encountered unexpected JWE Encrypted Key");case "ECDH-ES+A128KW":case "ECDH-ES+A192KW":case "ECDH-ES+A256KW":{if(!l(n.epk))throw new c('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(q(t),!Me(t))throw new h("ECDH with the provided key is not allowed or not supported by your javascript runtime");let i=await j(n.epk,e);q(i);let a,s;if(n.apu!==void 0){if(typeof n.apu!="string")throw new c('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{a=y(n.apu);}catch{throw new c("Failed to base64url decode the apu")}}if(n.apv!==void 0){if(typeof n.apv!="string")throw new c('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{s=y(n.apv);}catch{throw new c("Failed to base64url decode the apv")}}let d=await Ue(i,t,e==="ECDH-ES"?n.enc:e,e==="ECDH-ES"?Ee(n.enc):parseInt(e.slice(-5,-2),10),a,s);if(e==="ECDH-ES")return d;if(r===void 0)throw new c("JWE Encrypted Key missing");return Se(e.slice(-6),d,r)}case "RSA-OAEP":case "RSA-OAEP-256":case "RSA-OAEP-384":case "RSA-OAEP-512":{if(r===void 0)throw new c("JWE Encrypted Key missing");return q(t),Tt(e,t,r)}case "PBES2-HS256+A128KW":case "PBES2-HS384+A192KW":case "PBES2-HS512+A256KW":{if(r===void 0)throw new c("JWE Encrypted Key missing");if(typeof n.p2c!="number")throw new c('JOSE Header "p2c" (PBES2 Count) missing or invalid');let i=o?.maxPBES2Count||1e4;if(n.p2c>i)throw new c('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if(typeof n.p2s!="string")throw new c('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let a;try{a=y(n.p2s);}catch{throw new c("Failed to base64url decode the p2s")}return vt(e,t,r,n.p2c,a)}case "A128KW":case "A192KW":case "A256KW":{if(r===void 0)throw new c("JWE Encrypted Key missing");return Se(e,t,r)}case "A128GCMKW":case "A192GCMKW":case "A256GCMKW":{if(r===void 0)throw new c("JWE Encrypted Key missing");if(typeof n.iv!="string")throw new c('JOSE Header "iv" (Initialization Vector) missing or invalid');if(typeof n.tag!="string")throw new c('JOSE Header "tag" (Authentication Tag) missing or invalid');let i;try{i=y(n.iv);}catch{throw new c("Failed to base64url decode the iv")}let a;try{a=y(n.tag);}catch{throw new c("Failed to base64url decode the tag")}return Gt(e,t,r,i,a)}default:throw new h('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function _(e,t,r,n,o){if(o.crit!==void 0&&n?.crit===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||n.crit===void 0)return new Set;if(!Array.isArray(n.crit)||n.crit.length===0||n.crit.some(a=>typeof a!="string"||a.length===0))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let i;r!==void 0?i=new Map([...Object.entries(r),...t.entries()]):i=t;for(let a of n.crit){if(!i.has(a))throw new h(`Extension Header Parameter "${a}" is not recognized`);if(o[a]===void 0)throw new e(`Extension Header Parameter "${a}" is missing`);if(i.get(a)&&n[a]===void 0)throw new e(`Extension Header Parameter "${a}" MUST be integrity protected`)}return new Set(n.crit)}function Ae(e,t){if(t!==void 0&&(!Array.isArray(t)||t.some(r=>typeof r!="string")))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)}var ee=e=>l(e)&&typeof e.kty=="string",Ft=e=>e.kty!=="oct"&&(e.kty==="AKP"&&typeof e.priv=="string"||typeof e.d=="string"),zt=e=>e.kty!=="oct"&&e.d===void 0&&e.priv===void 0,Xt=e=>e.kty==="oct"&&typeof e.k=="string";var pe,Yt=async(e,t,r,n=false)=>{pe||=new WeakMap;let o=pe.get(e);if(o?.[r])return o[r];let i=await ce({...t,alg:r});return n&&Object.freeze(e),o?o[r]=i:pe.set(e,{[r]:i}),i},Wr=(e,t)=>{pe||=new WeakMap;let r=pe.get(e);if(r?.[t])return r[t];let n=e.type==="public",o=!!n,i;if(e.asymmetricKeyType==="x25519"){switch(t){case "ECDH-ES":case "ECDH-ES+A128KW":case "ECDH-ES+A192KW":case "ECDH-ES+A256KW":break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}i=e.toCryptoKey(e.asymmetricKeyType,o,n?[]:["deriveBits"]);}if(e.asymmetricKeyType==="ed25519"){if(t!=="EdDSA"&&t!=="Ed25519")throw new TypeError("given KeyObject instance cannot be used for this algorithm");i=e.toCryptoKey(e.asymmetricKeyType,o,[n?"verify":"sign"]);}switch(e.asymmetricKeyType){case "ml-dsa-44":case "ml-dsa-65":case "ml-dsa-87":{if(t!==e.asymmetricKeyType.toUpperCase())throw new TypeError("given KeyObject instance cannot be used for this algorithm");i=e.toCryptoKey(e.asymmetricKeyType,o,[n?"verify":"sign"]);}}if(e.asymmetricKeyType==="rsa"){let a;switch(t){case "RSA-OAEP":a="SHA-1";break;case "RS256":case "PS256":case "RSA-OAEP-256":a="SHA-256";break;case "RS384":case "PS384":case "RSA-OAEP-384":a="SHA-384";break;case "RS512":case "PS512":case "RSA-OAEP-512":a="SHA-512";break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}if(t.startsWith("RSA-OAEP"))return e.toCryptoKey({name:"RSA-OAEP",hash:a},o,n?["encrypt"]:["decrypt"]);i=e.toCryptoKey({name:t.startsWith("PS")?"RSA-PSS":"RSASSA-PKCS1-v1_5",hash:a},o,[n?"verify":"sign"]);}if(e.asymmetricKeyType==="ec"){let s=new Map([["prime256v1","P-256"],["secp384r1","P-384"],["secp521r1","P-521"]]).get(e.asymmetricKeyDetails?.namedCurve);if(!s)throw new TypeError("given KeyObject instance cannot be used for this algorithm");t==="ES256"&&s==="P-256"&&(i=e.toCryptoKey({name:"ECDSA",namedCurve:s},o,[n?"verify":"sign"])),t==="ES384"&&s==="P-384"&&(i=e.toCryptoKey({name:"ECDSA",namedCurve:s},o,[n?"verify":"sign"])),t==="ES512"&&s==="P-521"&&(i=e.toCryptoKey({name:"ECDSA",namedCurve:s},o,[n?"verify":"sign"])),t.startsWith("ECDH-ES")&&(i=e.toCryptoKey({name:"ECDH",namedCurve:s},o,n?[]:["deriveBits"]));}if(!i)throw new TypeError("given KeyObject instance cannot be used for this algorithm");return r?r[t]=i:pe.set(e,{[t]:i}),i};async function R(e,t){if(e instanceof Uint8Array||T(e))return e;if(Q(e)){if(e.type==="secret")return e.export();if("toCryptoKey"in e&&typeof e.toCryptoKey=="function")try{return Wr(e,t)}catch(n){if(n instanceof TypeError)throw n}let r=e.export({format:"jwk"});return Yt(e,r,t)}if(ee(e))return e.k?y(e.k):Yt(e,e,t,true);throw new Error("unreachable")}var de=e=>e?.[Symbol.toStringTag],rt=(e,t,r)=>{if(t.use!==void 0){let n;switch(r){case "sign":case "verify":n="sig";break;case "encrypt":case "decrypt":n="enc";break}if(t.use!==n)throw new TypeError(`Invalid key for this operation, its "use" must be "${n}" when present`)}if(t.alg!==void 0&&t.alg!==e)throw new TypeError(`Invalid key for this operation, its "alg" must be "${e}" when present`);if(Array.isArray(t.key_ops)){let n;switch(true){case(r==="sign"||r==="verify"):case e==="dir":case e.includes("CBC-HS"):n=r;break;case e.startsWith("PBES2"):n="deriveBits";break;case /^A\d{3}(?:GCM)?(?:KW)?$/.test(e):!e.includes("GCM")&&e.endsWith("KW")?n=r==="encrypt"?"wrapKey":"unwrapKey":n=r;break;case(r==="encrypt"&&e.startsWith("RSA")):n="wrapKey";break;case r==="decrypt":n=e.startsWith("RSA")?"unwrapKey":"deriveBits";break}if(n&&t.key_ops?.includes?.(n)===false)throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${n}" when present`)}return  true},vr=(e,t,r)=>{if(!(t instanceof Uint8Array)){if(ee(t)){if(Xt(t)&&rt(e,t,r))return;throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!ye(t))throw new TypeError(Xe(e,t,"CryptoKey","KeyObject","JSON Web Key","Uint8Array"));if(t.type!=="secret")throw new TypeError(`${de(t)} instances for symmetric algorithms must be of type "secret"`)}},Hr=(e,t,r)=>{if(ee(t))switch(r){case "decrypt":case "sign":if(Ft(t)&&rt(e,t,r))return;throw new TypeError("JSON Web Key for this operation must be a private JWK");case "encrypt":case "verify":if(zt(t)&&rt(e,t,r))return;throw new TypeError("JSON Web Key for this operation must be a public JWK")}if(!ye(t))throw new TypeError(Xe(e,t,"CryptoKey","KeyObject","JSON Web Key"));if(t.type==="secret")throw new TypeError(`${de(t)} instances for asymmetric algorithms must not be of type "secret"`);if(t.type==="public")switch(r){case "sign":throw new TypeError(`${de(t)} instances for asymmetric algorithm signing must be of type "private"`);case "decrypt":throw new TypeError(`${de(t)} instances for asymmetric algorithm decryption must be of type "private"`)}if(t.type==="private")switch(r){case "verify":throw new TypeError(`${de(t)} instances for asymmetric algorithm verifying must be of type "public"`);case "encrypt":throw new TypeError(`${de(t)} instances for asymmetric algorithm encryption must be of type "public"`)}};function N(e,t,r){switch(e.substring(0,2)){case "A1":case "A2":case "di":case "HS":case "PB":vr(e,t,r);break;default:Hr(e,t,r);}}async function ge(e,t,r){if(!l(e))throw new c("Flattened JWE must be an object");if(e.protected===void 0&&e.header===void 0&&e.unprotected===void 0)throw new c("JOSE Header missing");if(e.iv!==void 0&&typeof e.iv!="string")throw new c("JWE Initialization Vector incorrect type");if(typeof e.ciphertext!="string")throw new c("JWE Ciphertext missing or incorrect type");if(e.tag!==void 0&&typeof e.tag!="string")throw new c("JWE Authentication Tag incorrect type");if(e.protected!==void 0&&typeof e.protected!="string")throw new c("JWE Protected Header incorrect type");if(e.encrypted_key!==void 0&&typeof e.encrypted_key!="string")throw new c("JWE Encrypted Key incorrect type");if(e.aad!==void 0&&typeof e.aad!="string")throw new c("JWE AAD incorrect type");if(e.header!==void 0&&!l(e.header))throw new c("JWE Shared Unprotected Header incorrect type");if(e.unprotected!==void 0&&!l(e.unprotected))throw new c("JWE Per-Recipient Unprotected Header incorrect type");let n;if(e.protected)try{let oe=y(e.protected);n=JSON.parse(C.decode(oe));}catch{throw new c("JWE Protected Header is invalid")}if(!U(n,e.header,e.unprotected))throw new c("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");let o={...n,...e.header,...e.unprotected};if(_(c,new Map,r?.crit,n,o),o.zip!==void 0)throw new h('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');let{alg:i,enc:a}=o;if(typeof i!="string"||!i)throw new c("missing JWE Algorithm (alg) in JWE Header");if(typeof a!="string"||!a)throw new c("missing JWE Encryption Algorithm (enc) in JWE Header");let s=r&&Ae("keyManagementAlgorithms",r.keyManagementAlgorithms),d=r&&Ae("contentEncryptionAlgorithms",r.contentEncryptionAlgorithms);if(s&&!s.has(i)||!s&&i.startsWith("PBES2"))throw new $('"alg" (Algorithm) Header Parameter value not allowed');if(d&&!d.has(a))throw new $('"enc" (Encryption Algorithm) Header Parameter value not allowed');let p;if(e.encrypted_key!==void 0)try{p=y(e.encrypted_key);}catch{throw new c("Failed to base64url decode the encrypted_key")}let f=false;typeof t=="function"&&(t=await t(n,e),f=true),N(i==="dir"?a:i,t,"decrypt");let u=await R(t,i),b;try{b=await Vt(i,u,p,o,r);}catch(oe){if(oe instanceof TypeError||oe instanceof c||oe instanceof h)throw oe;b=M(a);}let H,S;if(e.iv!==void 0)try{H=y(e.iv);}catch{throw new c("Failed to base64url decode the iv")}if(e.tag!==void 0)try{S=y(e.tag);}catch{throw new c("Failed to base64url decode the tag")}let A=e.protected!==void 0?E(e.protected):new Uint8Array,v;e.aad!==void 0?v=x(A,E("."),E(e.aad)):v=A;let We;try{We=y(e.ciphertext);}catch{throw new c("Failed to base64url decode the ciphertext")}let ne={plaintext:await De(a,b,We,H,S,v)};if(e.protected!==void 0&&(ne.protectedHeader=n),e.aad!==void 0)try{ne.additionalAuthenticatedData=y(e.aad);}catch{throw new c("Failed to base64url decode the aad")}return e.unprotected!==void 0&&(ne.sharedUnprotectedHeader=e.unprotected),e.header!==void 0&&(ne.unprotectedHeader=e.header),f?{...ne,key:u}:ne}async function nt(e,t,r){if(e instanceof Uint8Array&&(e=C.decode(e)),typeof e!="string")throw new c("Compact JWE must be a string or Uint8Array");let{0:n,1:o,2:i,3:a,4:s,length:d}=e.split(".");if(d!==5)throw new c("Invalid Compact JWE");let p=await ge({ciphertext:a,iv:i||void 0,protected:n,tag:s||void 0,encrypted_key:o||void 0},t,r),f={plaintext:p.plaintext,protectedHeader:p.protectedHeader};return typeof t=="function"?{...f,key:p.key}:f}async function Jr(e,t,r){if(!l(e))throw new c("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(l))throw new c("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new c("JWE Recipients has no members");for(let n of e.recipients)try{return await ge({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:n.encrypted_key,header:n.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,r)}catch{}throw new B}var _e=Symbol();async function qt(e){if(Q(e))if(e.type==="secret")e=e.export();else return e.export({format:"jwk"});if(e instanceof Uint8Array)return {kty:"oct",k:w(e)};if(!T(e))throw new TypeError(I(e,"CryptoKey","KeyObject","Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");let{ext:t,key_ops:r,alg:n,use:o,...i}=await crypto.subtle.exportKey("jwk",e);return i.kty==="AKP"&&(i.alg=n),i}async function Ir(e){return Ut(e)}async function Tr(e){return Mt(e)}async function be(e){return qt(e)}async function Ne(e,t,r,n,o={}){let i,a,s;switch(e){case "dir":{s=r;break}case "ECDH-ES":case "ECDH-ES+A128KW":case "ECDH-ES+A192KW":case "ECDH-ES+A256KW":{if(q(r),!Me(r))throw new h("ECDH with the provided key is not allowed or not supported by your javascript runtime");let{apu:d,apv:p}=o,f;o.epk?f=await R(o.epk,e):f=(await crypto.subtle.generateKey(r.algorithm,true,["deriveBits"])).privateKey;let{x:u,y:b,crv:H,kty:S}=await be(f),A=await Ue(r,f,e==="ECDH-ES"?t:e,e==="ECDH-ES"?Ee(t):parseInt(e.slice(-5,-2),10),d,p);if(a={epk:{x:u,crv:H,kty:S}},S==="EC"&&(a.epk.y=b),d&&(a.apu=w(d)),p&&(a.apv=w(p)),e==="ECDH-ES"){s=A;break}s=n||M(t);let v=e.slice(-6);i=await we(v,A,s);break}case "RSA-OAEP":case "RSA-OAEP-256":case "RSA-OAEP-384":case "RSA-OAEP-512":{s=n||M(t),q(r),i=await It(e,r,s);break}case "PBES2-HS256+A128KW":case "PBES2-HS384+A192KW":case "PBES2-HS512+A256KW":{s=n||M(t);let{p2c:d,p2s:p}=o;({encryptedKey:i,...a}=await Wt(e,r,s,d,p));break}case "A128KW":case "A192KW":case "A256KW":{s=n||M(t),i=await we(e,r,s);break}case "A128GCMKW":case "A192GCMKW":case "A256GCMKW":{s=n||M(t);let{iv:d}=o;({encryptedKey:i,...a}=await $t(e,r,s,d));break}default:throw new h('Invalid or unsupported "alg" (JWE Algorithm) header value')}return {cek:s,encryptedKey:i,parameters:a}}var G=class{#e;#t;#r;#n;#i;#a;#s;#o;constructor(t){if(!(t instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this.#e=t;}setKeyManagementParameters(t){if(this.#o)throw new TypeError("setKeyManagementParameters can only be called once");return this.#o=t,this}setProtectedHeader(t){if(this.#t)throw new TypeError("setProtectedHeader can only be called once");return this.#t=t,this}setSharedUnprotectedHeader(t){if(this.#r)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this.#r=t,this}setUnprotectedHeader(t){if(this.#n)throw new TypeError("setUnprotectedHeader can only be called once");return this.#n=t,this}setAdditionalAuthenticatedData(t){return this.#i=t,this}setContentEncryptionKey(t){if(this.#a)throw new TypeError("setContentEncryptionKey can only be called once");return this.#a=t,this}setInitializationVector(t){if(this.#s)throw new TypeError("setInitializationVector can only be called once");return this.#s=t,this}async encrypt(t,r){if(!this.#t&&!this.#n&&!this.#r)throw new c("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!U(this.#t,this.#n,this.#r))throw new c("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");let n={...this.#t,...this.#n,...this.#r};if(_(c,new Map,r?.crit,this.#t,n),n.zip!==void 0)throw new h('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');let{alg:o,enc:i}=n;if(typeof o!="string"||!o)throw new c('JWE "alg" (Algorithm) Header Parameter missing or invalid');if(typeof i!="string"||!i)throw new c('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let a;if(this.#a&&(o==="dir"||o==="ECDH-ES"))throw new TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${o}`);N(o==="dir"?i:o,t,"encrypt");let s;{let v,We=await R(t,o);(({cek:s,encryptedKey:a,parameters:v}=await Ne(o,i,We,this.#a,this.#o))),v&&(r&&_e in r?this.#n?this.#n={...this.#n,...v}:this.setUnprotectedHeader(v):this.#t?this.#t={...this.#t,...v}:this.setProtectedHeader(v));}let d,p,f,u;if(this.#t?(p=w(JSON.stringify(this.#t)),f=E(p)):(p="",f=new Uint8Array),this.#i){u=w(this.#i);let v=E(u);d=x(f,E("."),v);}else d=f;let{ciphertext:b,tag:H,iv:S}=await ke(i,this.#e,s,this.#s,d),A={ciphertext:w(b)};return S&&(A.iv=w(S)),H&&(A.tag=w(H)),a&&(A.encrypted_key=w(a)),u&&(A.aad=u),this.#t&&(A.protected=p),this.#r&&(A.unprotected=this.#r),this.#n&&(A.header=this.#n),A}};var ot=class{#e;unprotectedHeader;keyManagementParameters;key;options;constructor(t,r,n){this.#e=t,this.key=r,this.options=n;}setUnprotectedHeader(t){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=t,this}setKeyManagementParameters(t){if(this.keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this.keyManagementParameters=t,this}addRecipient(...t){return this.#e.addRecipient(...t)}encrypt(...t){return this.#e.encrypt(...t)}done(){return this.#e}},it=class{#e;#t=[];#r;#n;#i;constructor(t){this.#e=t;}addRecipient(t,r){let n=new ot(this,t,{crit:r?.crit});return this.#t.push(n),n}setProtectedHeader(t){if(this.#r)throw new TypeError("setProtectedHeader can only be called once");return this.#r=t,this}setSharedUnprotectedHeader(t){if(this.#n)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this.#n=t,this}setAdditionalAuthenticatedData(t){return this.#i=t,this}async encrypt(){if(!this.#t.length)throw new c("at least one recipient must be added");if(this.#t.length===1){let[o]=this.#t,i=await new G(this.#e).setAdditionalAuthenticatedData(this.#i).setProtectedHeader(this.#r).setSharedUnprotectedHeader(this.#n).setUnprotectedHeader(o.unprotectedHeader).encrypt(o.key,{...o.options}),a={ciphertext:i.ciphertext,iv:i.iv,recipients:[{}],tag:i.tag};return i.aad&&(a.aad=i.aad),i.protected&&(a.protected=i.protected),i.unprotected&&(a.unprotected=i.unprotected),i.encrypted_key&&(a.recipients[0].encrypted_key=i.encrypted_key),i.header&&(a.recipients[0].header=i.header),a}let t;for(let o=0;o<this.#t.length;o++){let i=this.#t[o];if(!U(this.#r,this.#n,i.unprotectedHeader))throw new c("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");let a={...this.#r,...this.#n,...i.unprotectedHeader},{alg:s}=a;if(typeof s!="string"||!s)throw new c('JWE "alg" (Algorithm) Header Parameter missing or invalid');if(s==="dir"||s==="ECDH-ES")throw new c('"dir" and "ECDH-ES" alg may only be used with a single recipient');if(typeof a.enc!="string"||!a.enc)throw new c('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(!t)t=a.enc;else if(t!==a.enc)throw new c('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');if(_(c,new Map,i.options.crit,this.#r,a),a.zip!==void 0)throw new h('JWE "zip" (Compression Algorithm) Header Parameter is not supported.')}let r=M(t),n={ciphertext:"",recipients:[]};for(let o=0;o<this.#t.length;o++){let i=this.#t[o],a={};if(n.recipients.push(a),o===0){let u=await new G(this.#e).setAdditionalAuthenticatedData(this.#i).setContentEncryptionKey(r).setProtectedHeader(this.#r).setSharedUnprotectedHeader(this.#n).setUnprotectedHeader(i.unprotectedHeader).setKeyManagementParameters(i.keyManagementParameters).encrypt(i.key,{...i.options,[_e]:true});n.ciphertext=u.ciphertext,n.iv=u.iv,n.tag=u.tag,u.aad&&(n.aad=u.aad),u.protected&&(n.protected=u.protected),u.unprotected&&(n.unprotected=u.unprotected),a.encrypted_key=u.encrypted_key,u.header&&(a.header=u.header);continue}let s=i.unprotectedHeader?.alg||this.#r?.alg||this.#n?.alg;N(s==="dir"?t:s,i.key,"encrypt");let d=await R(i.key,s),{encryptedKey:p,parameters:f}=await Ne(s,t,d,r,i.keyManagementParameters);a.encrypted_key=w(p),(i.unprotectedHeader||f)&&(a.header={...i.unprotectedHeader,...f});}return n}};function Le(e,t){let r=`SHA-${e.slice(-3)}`;switch(e){case "HS256":case "HS384":case "HS512":return {hash:r,name:"HMAC"};case "PS256":case "PS384":case "PS512":return {hash:r,name:"RSA-PSS",saltLength:parseInt(e.slice(-3),10)>>3};case "RS256":case "RS384":case "RS512":return {hash:r,name:"RSASSA-PKCS1-v1_5"};case "ES256":case "ES384":case "ES512":return {hash:r,name:"ECDSA",namedCurve:t.namedCurve};case "Ed25519":case "EdDSA":return {name:"Ed25519"};case "ML-DSA-44":case "ML-DSA-65":case "ML-DSA-87":return {name:e};default:throw new h(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}async function Be(e,t,r){if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(I(t,"CryptoKey","KeyObject","JSON Web Key"));return crypto.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},false,[r])}return gt(t,e,r),t}async function Qt(e,t,r,n){let o=await Be(e,t,"verify");Z(e,o);let i=Le(e,o.algorithm);try{return await crypto.subtle.verify(i,o,r,n)}catch{return  false}}async function Ke(e,t,r){if(!l(e))throw new m("Flattened JWS must be an object");if(e.protected===void 0&&e.header===void 0)throw new m('Flattened JWS must have either of the "protected" or "header" members');if(e.protected!==void 0&&typeof e.protected!="string")throw new m("JWS Protected Header incorrect type");if(e.payload===void 0)throw new m("JWS Payload missing");if(typeof e.signature!="string")throw new m("JWS Signature missing or incorrect type");if(e.header!==void 0&&!l(e.header))throw new m("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{let v=y(e.protected);n=JSON.parse(C.decode(v));}catch{throw new m("JWS Protected Header is invalid")}if(!U(n,e.header))throw new m("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");let o={...n,...e.header},i=_(m,new Map([["b64",true]]),r?.crit,n,o),a=true;if(i.has("b64")&&(a=n.b64,typeof a!="boolean"))throw new m('The "b64" (base64url-encode payload) Header Parameter must be a boolean');let{alg:s}=o;if(typeof s!="string"||!s)throw new m('JWS "alg" (Algorithm) Header Parameter missing or invalid');let d=r&&Ae("algorithms",r.algorithms);if(d&&!d.has(s))throw new $('"alg" (Algorithm) Header Parameter value not allowed');if(a){if(typeof e.payload!="string")throw new m("JWS Payload must be a string")}else if(typeof e.payload!="string"&&!(e.payload instanceof Uint8Array))throw new m("JWS Payload must be a string or an Uint8Array instance");let p=false;typeof t=="function"&&(t=await t(n,e),p=true),N(s,t,"verify");let f=x(e.protected!==void 0?E(e.protected):new Uint8Array,E("."),typeof e.payload=="string"?a?E(e.payload):z.encode(e.payload):e.payload),u;try{u=y(e.signature);}catch{throw new m("Failed to base64url decode the signature")}let b=await R(t,s);if(!await Qt(s,b,u,f))throw new Y;let S;if(a)try{S=y(e.payload);}catch{throw new m("Failed to base64url decode the payload")}else typeof e.payload=="string"?S=z.encode(e.payload):S=e.payload;let A={payload:S};return e.protected!==void 0&&(A.protectedHeader=n),e.header!==void 0&&(A.unprotectedHeader=e.header),p?{...A,key:b}:A}async function at(e,t,r){if(e instanceof Uint8Array&&(e=C.decode(e)),typeof e!="string")throw new m("Compact JWS must be a string or Uint8Array");let{0:n,1:o,2:i,length:a}=e.split(".");if(a!==3)throw new m("Invalid Compact JWS");let s=await Ke({payload:o,protected:n,signature:i},t,r),d={payload:s.payload,protectedHeader:s.protectedHeader};return typeof t=="function"?{...d,key:s.key}:d}async function Rr(e,t,r){if(!l(e))throw new m("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(l))throw new m("JWS Signatures missing or incorrect type");for(let n of e.signatures)try{return await Ke({header:n.header,payload:e.payload,protected:n.protected,signature:n.signature},t,r)}catch{}throw new Y}var V=e=>Math.floor(e.getTime()/1e3),jt=60,er=jt*60,st=er*24,Dr=st*7,Or=st*365.25,Ur=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;function Ce(e){let t=Ur.exec(e);if(!t||t[4]&&t[1])throw new TypeError("Invalid time period format");let r=parseFloat(t[2]),n=t[3].toLowerCase(),o;switch(n){case "sec":case "secs":case "second":case "seconds":case "s":o=Math.round(r);break;case "minute":case "minutes":case "min":case "mins":case "m":o=Math.round(r*jt);break;case "hour":case "hours":case "hr":case "hrs":case "h":o=Math.round(r*er);break;case "day":case "days":case "d":o=Math.round(r*st);break;case "week":case "weeks":case "w":o=Math.round(r*Dr);break;default:o=Math.round(r*Or);break}return t[1]==="-"||t[4]==="ago"?-o:o}function te(e,t){if(!Number.isFinite(t))throw new TypeError(`Invalid ${e} input`);return t}var Zt=e=>e.includes("/")?e.toLowerCase():`application/${e.toLowerCase()}`,Mr=(e,t)=>typeof e=="string"?t.includes(e):Array.isArray(e)?t.some(Set.prototype.has.bind(new Set(e))):false;function fe(e,t,r={}){let n;try{n=JSON.parse(C.decode(t));}catch{}if(!l(n))throw new g("JWT Claims Set must be a top-level JSON object");let{typ:o}=r;if(o&&(typeof e.typ!="string"||Zt(e.typ)!==Zt(o)))throw new P('unexpected "typ" JWT header value',n,"typ","check_failed");let{requiredClaims:i=[],issuer:a,subject:s,audience:d,maxTokenAge:p}=r,f=[...i];p!==void 0&&f.push("iat"),d!==void 0&&f.push("aud"),s!==void 0&&f.push("sub"),a!==void 0&&f.push("iss");for(let S of new Set(f.reverse()))if(!(S in n))throw new P(`missing required "${S}" claim`,n,S,"missing");if(a&&!(Array.isArray(a)?a:[a]).includes(n.iss))throw new P('unexpected "iss" claim value',n,"iss","check_failed");if(s&&n.sub!==s)throw new P('unexpected "sub" claim value',n,"sub","check_failed");if(d&&!Mr(n.aud,typeof d=="string"?[d]:d))throw new P('unexpected "aud" claim value',n,"aud","check_failed");let u;switch(typeof r.clockTolerance){case "string":u=Ce(r.clockTolerance);break;case "number":u=r.clockTolerance;break;case "undefined":u=0;break;default:throw new TypeError("Invalid clockTolerance option type")}let{currentDate:b}=r,H=V(b||new Date);if((n.iat!==void 0||p)&&typeof n.iat!="number")throw new P('"iat" claim must be a number',n,"iat","invalid");if(n.nbf!==void 0){if(typeof n.nbf!="number")throw new P('"nbf" claim must be a number',n,"nbf","invalid");if(n.nbf>H+u)throw new P('"nbf" claim timestamp check failed',n,"nbf","check_failed")}if(n.exp!==void 0){if(typeof n.exp!="number")throw new P('"exp" claim must be a number',n,"exp","invalid");if(n.exp<=H-u)throw new ie('"exp" claim timestamp check failed',n,"exp","check_failed")}if(p){let S=H-n.iat,A=typeof p=="number"?p:Ce(p);if(S-u>A)throw new ie('"iat" claim timestamp check failed (too far in the past)',n,"iat","check_failed");if(S<0-u)throw new P('"iat" claim timestamp check failed (it should be in the past)',n,"iat","check_failed")}return n}var F=class{#e;constructor(t){if(!l(t))throw new TypeError("JWT Claims Set MUST be an object");this.#e=structuredClone(t);}data(){return z.encode(JSON.stringify(this.#e))}get iss(){return this.#e.iss}set iss(t){this.#e.iss=t;}get sub(){return this.#e.sub}set sub(t){this.#e.sub=t;}get aud(){return this.#e.aud}set aud(t){this.#e.aud=t;}set jti(t){this.#e.jti=t;}set nbf(t){typeof t=="number"?this.#e.nbf=te("setNotBefore",t):t instanceof Date?this.#e.nbf=te("setNotBefore",V(t)):this.#e.nbf=V(new Date)+Ce(t);}set exp(t){typeof t=="number"?this.#e.exp=te("setExpirationTime",t):t instanceof Date?this.#e.exp=te("setExpirationTime",V(t)):this.#e.exp=V(new Date)+Ce(t);}set iat(t){t===void 0?this.#e.iat=V(new Date):t instanceof Date?this.#e.iat=te("setIssuedAt",V(t)):typeof t=="string"?this.#e.iat=te("setIssuedAt",V(new Date)+Ce(t)):this.#e.iat=te("setIssuedAt",t);}};async function kr(e,t,r){let n=await at(e,t,r);if(n.protectedHeader.crit?.includes("b64")&&n.protectedHeader.b64===false)throw new g("JWTs MUST NOT use unencoded payload");let i={payload:fe(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return typeof t=="function"?{...i,key:n.key}:i}async function _r(e,t,r){let n=await nt(e,t,r),o=fe(n.protectedHeader,n.plaintext,r),{protectedHeader:i}=n;if(i.iss!==void 0&&i.iss!==o.iss)throw new P('replicated "iss" claim header parameter mismatch',o,"iss","mismatch");if(i.sub!==void 0&&i.sub!==o.sub)throw new P('replicated "sub" claim header parameter mismatch',o,"sub","mismatch");if(i.aud!==void 0&&JSON.stringify(i.aud)!==JSON.stringify(o.aud))throw new P('replicated "aud" claim header parameter mismatch',o,"aud","mismatch");let a={payload:o,protectedHeader:i};return typeof t=="function"?{...a,key:n.key}:a}var xe=class{#e;constructor(t){this.#e=new G(t);}setContentEncryptionKey(t){return this.#e.setContentEncryptionKey(t),this}setInitializationVector(t){return this.#e.setInitializationVector(t),this}setProtectedHeader(t){return this.#e.setProtectedHeader(t),this}setKeyManagementParameters(t){return this.#e.setKeyManagementParameters(t),this}async encrypt(t,r){let n=await this.#e.encrypt(t,r);return [n.protected,n.encrypted_key,n.iv,n.ciphertext,n.tag].join(".")}};async function tr(e,t,r){let n=await Be(e,t,"sign");Z(e,n);let o=await crypto.subtle.sign(Le(e,n.algorithm),n,r);return new Uint8Array(o)}var re=class{#e;#t;#r;constructor(t){if(!(t instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this.#e=t;}setProtectedHeader(t){if(this.#t)throw new TypeError("setProtectedHeader can only be called once");return this.#t=t,this}setUnprotectedHeader(t){if(this.#r)throw new TypeError("setUnprotectedHeader can only be called once");return this.#r=t,this}async sign(t,r){if(!this.#t&&!this.#r)throw new m("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!U(this.#t,this.#r))throw new m("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");let n={...this.#t,...this.#r},o=_(m,new Map([["b64",true]]),r?.crit,this.#t,n),i=true;if(o.has("b64")&&(i=this.#t.b64,typeof i!="boolean"))throw new m('The "b64" (base64url-encode payload) Header Parameter must be a boolean');let{alg:a}=n;if(typeof a!="string"||!a)throw new m('JWS "alg" (Algorithm) Header Parameter missing or invalid');N(a,t,"sign");let s,d;i?(s=w(this.#e),d=E(s)):(d=this.#e,s="");let p,f;this.#t?(p=w(JSON.stringify(this.#t)),f=E(p)):(p="",f=new Uint8Array);let u=x(f,E("."),d),b=await R(t,a),H=await tr(a,b,u),S={signature:w(H),payload:s};return this.#r&&(S.header=this.#r),this.#t&&(S.protected=p),S}};var Pe=class{#e;constructor(t){this.#e=new re(t);}setProtectedHeader(t){return this.#e.setProtectedHeader(t),this}async sign(t,r){let n=await this.#e.sign(t,r);if(n.payload===void 0)throw new TypeError("use the flattened module for creating JWS with b64: false");return `${n.protected}.${n.payload}.${n.signature}`}};var ct=class{#e;protectedHeader;unprotectedHeader;options;key;constructor(t,r,n){this.#e=t,this.key=r,this.options=n;}setProtectedHeader(t){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=t,this}setUnprotectedHeader(t){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=t,this}addSignature(...t){return this.#e.addSignature(...t)}sign(...t){return this.#e.sign(...t)}done(){return this.#e}},pt=class{#e;#t=[];constructor(t){this.#e=t;}addSignature(t,r){let n=new ct(this,t,r);return this.#t.push(n),n}async sign(){if(!this.#t.length)throw new m("at least one signature must be added");let t={signatures:[],payload:""};for(let r=0;r<this.#t.length;r++){let n=this.#t[r],o=new re(this.#e);o.setProtectedHeader(n.protectedHeader),o.setUnprotectedHeader(n.unprotectedHeader);let{payload:i,...a}=await o.sign(n.key,n.options);if(r===0)t.payload=i;else if(t.payload!==i)throw new m("inconsistent use of JWS Unencoded Payload (RFC7797)");t.signatures.push(a);}return t}};var dt=class{#e;#t;constructor(t={}){this.#t=new F(t);}setIssuer(t){return this.#t.iss=t,this}setSubject(t){return this.#t.sub=t,this}setAudience(t){return this.#t.aud=t,this}setJti(t){return this.#t.jti=t,this}setNotBefore(t){return this.#t.nbf=t,this}setExpirationTime(t){return this.#t.exp=t,this}setIssuedAt(t){return this.#t.iat=t,this}setProtectedHeader(t){return this.#e=t,this}async sign(t,r){let n=new Pe(this.#t.data());if(n.setProtectedHeader(this.#e),Array.isArray(this.#e?.crit)&&this.#e.crit.includes("b64")&&this.#e.b64===false)throw new g("JWTs MUST NOT use unencoded payload");return n.sign(t,r)}};var ft=class{#e;#t;#r;#n;#i;#a;#s;#o;constructor(t={}){this.#o=new F(t);}setIssuer(t){return this.#o.iss=t,this}setSubject(t){return this.#o.sub=t,this}setAudience(t){return this.#o.aud=t,this}setJti(t){return this.#o.jti=t,this}setNotBefore(t){return this.#o.nbf=t,this}setExpirationTime(t){return this.#o.exp=t,this}setIssuedAt(t){return this.#o.iat=t,this}setProtectedHeader(t){if(this.#n)throw new TypeError("setProtectedHeader can only be called once");return this.#n=t,this}setKeyManagementParameters(t){if(this.#r)throw new TypeError("setKeyManagementParameters can only be called once");return this.#r=t,this}setContentEncryptionKey(t){if(this.#e)throw new TypeError("setContentEncryptionKey can only be called once");return this.#e=t,this}setInitializationVector(t){if(this.#t)throw new TypeError("setInitializationVector can only be called once");return this.#t=t,this}replicateIssuerAsHeader(){return this.#i=true,this}replicateSubjectAsHeader(){return this.#a=true,this}replicateAudienceAsHeader(){return this.#s=true,this}async encrypt(t,r){let n=new xe(this.#o.data());return this.#n&&(this.#i||this.#a||this.#s)&&(this.#n={...this.#n,iss:this.#i?this.#o.iss:void 0,sub:this.#a?this.#o.sub:void 0,aud:this.#s?this.#o.aud:void 0}),n.setProtectedHeader(this.#n),this.#t&&n.setInitializationVector(this.#t),this.#e&&n.setContentEncryptionKey(this.#e),this.#r&&n.setKeyManagementParameters(this.#r),n.encrypt(t,r)}};var L=(e,t)=>{if(typeof e!="string"||!e)throw new ue(`${t} missing or invalid`)};async function rr(e,t){let r;if(ee(e))r=e;else if(ye(e))r=await be(e);else throw new TypeError(I(e,"CryptoKey","KeyObject","JSON Web Key"));if(t??="sha256",t!=="sha256"&&t!=="sha384"&&t!=="sha512")throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');let n;switch(r.kty){case "AKP":L(r.alg,'"alg" (Algorithm) Parameter'),L(r.pub,'"pub" (Public key) Parameter'),n={alg:r.alg,kty:r.kty,pub:r.pub};break;case "EC":L(r.crv,'"crv" (Curve) Parameter'),L(r.x,'"x" (X Coordinate) Parameter'),L(r.y,'"y" (Y Coordinate) Parameter'),n={crv:r.crv,kty:r.kty,x:r.x,y:r.y};break;case "OKP":L(r.crv,'"crv" (Subtype of Key Pair) Parameter'),L(r.x,'"x" (Public Key) Parameter'),n={crv:r.crv,kty:r.kty,x:r.x};break;case "RSA":L(r.e,'"e" (Exponent) Parameter'),L(r.n,'"n" (Modulus) Parameter'),n={e:r.e,kty:r.kty,n:r.n};break;case "oct":L(r.k,'"k" (Key Value) Parameter'),n={k:r.k,kty:r.kty};break;default:throw new h('"kty" (Key Type) Parameter missing or unsupported')}let o=E(JSON.stringify(n));return w(await Oe(t,o))}async function Nr(e,t){t??="sha256";let r=await rr(e,t);return `urn:ietf:params:oauth:jwk-thumbprint:sha-${t.slice(-3)}:${r}`}async function Lr(e,t){let r={...e,...t?.header};if(!l(r.jwk))throw new m('"jwk" (JSON Web Key) Header Parameter must be a JSON object');let n=await j({...r.jwk,ext:true},r.alg);if(n instanceof Uint8Array||n.type!=="public")throw new m('"jwk" (JSON Web Key) Header Parameter must be a public key');return n}function Br(e){switch(typeof e=="string"&&e.slice(0,2)){case "RS":case "PS":return "RSA";case "ES":return "EC";case "Ed":return "OKP";case "ML":return "AKP";default:throw new h('Unsupported "alg" value for a JSON Web Key Set')}}function $r(e){return e&&typeof e=="object"&&Array.isArray(e.keys)&&e.keys.every(Gr)}function Gr(e){return l(e)}var ht=class{#e;#t=new WeakMap;constructor(t){if(!$r(t))throw new ae("JSON Web Key Set malformed");this.#e=structuredClone(t);}jwks(){return this.#e}async getKey(t,r){let{alg:n,kid:o}={...t,...r?.header},i=Br(n),a=this.#e.keys.filter(p=>{let f=i===p.kty;if(f&&typeof o=="string"&&(f=o===p.kid),f&&(typeof p.alg=="string"||i==="AKP")&&(f=n===p.alg),f&&typeof p.use=="string"&&(f=p.use==="sig"),f&&Array.isArray(p.key_ops)&&(f=p.key_ops.includes("verify")),f)switch(n){case "ES256":f=p.crv==="P-256";break;case "ES384":f=p.crv==="P-384";break;case "ES512":f=p.crv==="P-521";break;case "Ed25519":case "EdDSA":f=p.crv==="Ed25519";break}return f}),{0:s,length:d}=a;if(d===0)throw new X;if(d!==1){let p=new me,f=this.#t;throw p[Symbol.asyncIterator]=async function*(){for(let u of a)try{yield await nr(f,u,n);}catch{}},p}return nr(this.#t,s,n)}};async function nr(e,t,r){let n=e.get(t)||e.set(t,{}).get(t);if(n[r]===void 0){let o=await j({...t,ext:true},r);if(o instanceof Uint8Array||o.type!=="public")throw new ae("JSON Web Key Set members must be public keys");n[r]=o;}return n[r]}function $e(e){let t=new ht(e),r=async(n,o)=>t.getKey(n,o);return Object.defineProperties(r,{jwks:{value:()=>structuredClone(t.jwks()),enumerable:false,configurable:false,writable:false}}),r}function Vr(){return typeof WebSocketPair<"u"||typeof navigator<"u"&&navigator.userAgent==="Cloudflare-Workers"||typeof EdgeRuntime<"u"&&EdgeRuntime==="vercel"}var ut;(typeof navigator>"u"||!navigator.userAgent?.startsWith?.("Mozilla/5.0 "))&&(ut="jose/v6.1.3");var or=Symbol();async function Fr(e,t,r,n=fetch){let o=await n(e,{method:"GET",signal:r,redirect:"manual",headers:t}).catch(i=>{throw i.name==="TimeoutError"?new le:i});if(o.status!==200)throw new K("Expected 200 OK from the JSON Web Key Set HTTP response");try{return await o.json()}catch{throw new K("Failed to parse the JSON Web Key Set HTTP response as JSON")}}var Ge=Symbol();function zr(e,t){return !(typeof e!="object"||e===null||!("uat"in e)||typeof e.uat!="number"||Date.now()-e.uat>=t||!("jwks"in e)||!l(e.jwks)||!Array.isArray(e.jwks.keys)||!Array.prototype.every.call(e.jwks.keys,l))}var mt=class{#e;#t;#r;#n;#i;#a;#s;#o;#c;#p;constructor(t,r){if(!(t instanceof URL))throw new TypeError("url must be an instance of URL");this.#e=new URL(t.href),this.#t=typeof r?.timeoutDuration=="number"?r?.timeoutDuration:5e3,this.#r=typeof r?.cooldownDuration=="number"?r?.cooldownDuration:3e4,this.#n=typeof r?.cacheMaxAge=="number"?r?.cacheMaxAge:6e5,this.#s=new Headers(r?.headers),ut&&!this.#s.has("User-Agent")&&this.#s.set("User-Agent",ut),this.#s.has("accept")||(this.#s.set("accept","application/json"),this.#s.append("accept","application/jwk-set+json")),this.#o=r?.[or],r?.[Ge]!==void 0&&(this.#p=r?.[Ge],zr(r?.[Ge],this.#n)&&(this.#i=this.#p.uat,this.#c=$e(this.#p.jwks)));}pendingFetch(){return !!this.#a}coolingDown(){return typeof this.#i=="number"?Date.now()<this.#i+this.#r:false}fresh(){return typeof this.#i=="number"?Date.now()<this.#i+this.#n:false}jwks(){return this.#c?.jwks()}async getKey(t,r){(!this.#c||!this.fresh())&&await this.reload();try{return await this.#c(t,r)}catch(n){if(n instanceof X&&this.coolingDown()===false)return await this.reload(),this.#c(t,r);throw n}}async reload(){this.#a&&Vr()&&(this.#a=void 0),this.#a||=Fr(this.#e.href,this.#s,AbortSignal.timeout(this.#t),this.#o).then(t=>{this.#c=$e(t),this.#p&&(this.#p.uat=Date.now(),this.#p.jwks=t),this.#i=Date.now(),this.#a=void 0;}).catch(t=>{throw this.#a=void 0,t}),await this.#a;}};function Xr(e,t){let r=new mt(e,t),n=async(o,i)=>r.getKey(o,i);return Object.defineProperties(n,{coolingDown:{get:()=>r.coolingDown(),enumerable:true,configurable:false},fresh:{get:()=>r.fresh(),enumerable:true,configurable:false},reload:{value:()=>r.reload(),enumerable:true,configurable:false,writable:false},reloading:{get:()=>r.pendingFetch(),enumerable:true,configurable:false},jwks:{value:()=>r.jwks(),enumerable:true,configurable:false,writable:false}}),n}var lt=class{#e;constructor(t={}){this.#e=new F(t);}encode(){let t=w(JSON.stringify({alg:"none"})),r=w(this.#e.data());return `${t}.${r}.`}setIssuer(t){return this.#e.iss=t,this}setSubject(t){return this.#e.sub=t,this}setAudience(t){return this.#e.aud=t,this}setJti(t){return this.#e.jti=t,this}setNotBefore(t){return this.#e.nbf=t,this}setExpirationTime(t){return this.#e.exp=t,this}setIssuedAt(t){return this.#e.iat=t,this}static decode(t,r){if(typeof t!="string")throw new g("Unsecured JWT must be a string");let{0:n,1:o,2:i,length:a}=t.split(".");if(a!==3||i!=="")throw new g("Invalid Unsecured JWT");let s;try{if(s=JSON.parse(C.decode(y(n))),s.alg!=="none")throw new Error}catch{throw new g("Invalid Unsecured JWT")}return {payload:fe(s,y(o),r),header:s}}};function Yr(e){let t;if(typeof e=="string"){let r=e.split(".");(r.length===3||r.length===5)&&([t]=r);}else if(typeof e=="object"&&e)if("protected"in e)t=e.protected;else throw new TypeError("Token does not contain a Protected Header");try{if(typeof t!="string"||!t)throw new Error;let r=JSON.parse(C.decode(y(t)));if(!l(r))throw new Error;return r}catch{throw new TypeError("Invalid Token or Protected Header formatting")}}function qr(e){if(typeof e!="string")throw new g("JWTs must use Compact JWS serialization, JWT must be a string");let{1:t,length:r}=e.split(".");if(r===5)throw new g("Only JWTs using Compact JWS serialization can be decoded");if(r!==3)throw new g("Invalid JWT");if(!t)throw new g("JWTs must contain a payload");let n;try{n=y(t);}catch{throw new g("Failed to base64url decode the payload")}let o;try{o=JSON.parse(C.decode(n));}catch{throw new g("Failed to parse the decoded payload as JSON")}if(!l(o))throw new g("Invalid JWT Claims Set");return o}function yt(e){let t=e?.modulusLength??2048;if(typeof t!="number"||t<2048)throw new h("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return t}async function Qr(e,t){let r,n;switch(e){case "PS256":case "PS384":case "PS512":r={name:"RSA-PSS",hash:`SHA-${e.slice(-3)}`,publicExponent:Uint8Array.of(1,0,1),modulusLength:yt(t)},n=["sign","verify"];break;case "RS256":case "RS384":case "RS512":r={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.slice(-3)}`,publicExponent:Uint8Array.of(1,0,1),modulusLength:yt(t)},n=["sign","verify"];break;case "RSA-OAEP":case "RSA-OAEP-256":case "RSA-OAEP-384":case "RSA-OAEP-512":r={name:"RSA-OAEP",hash:`SHA-${parseInt(e.slice(-3),10)||1}`,publicExponent:Uint8Array.of(1,0,1),modulusLength:yt(t)},n=["decrypt","unwrapKey","encrypt","wrapKey"];break;case "ES256":r={name:"ECDSA",namedCurve:"P-256"},n=["sign","verify"];break;case "ES384":r={name:"ECDSA",namedCurve:"P-384"},n=["sign","verify"];break;case "ES512":r={name:"ECDSA",namedCurve:"P-521"},n=["sign","verify"];break;case "Ed25519":case "EdDSA":{n=["sign","verify"],r={name:"Ed25519"};break}case "ML-DSA-44":case "ML-DSA-65":case "ML-DSA-87":{n=["sign","verify"],r={name:e};break}case "ECDH-ES":case "ECDH-ES+A128KW":case "ECDH-ES+A192KW":case "ECDH-ES+A256KW":{n=["deriveBits"];let o=t?.crv??"P-256";switch(o){case "P-256":case "P-384":case "P-521":{r={name:"ECDH",namedCurve:o};break}case "X25519":r={name:"X25519"};break;default:throw new h("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, and X25519")}break}default:throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return crypto.subtle.generateKey(r,t?.extractable??false,n)}async function Zr(e,t){let r,n,o;switch(e){case "HS256":case "HS384":case "HS512":r=parseInt(e.slice(-3),10),n={name:"HMAC",hash:`SHA-${r}`,length:r},o=["sign","verify"];break;case "A128CBC-HS256":case "A192CBC-HS384":case "A256CBC-HS512":return r=parseInt(e.slice(-3),10),crypto.getRandomValues(new Uint8Array(r>>3));case "A128KW":case "A192KW":case "A256KW":r=parseInt(e.slice(1,4),10),n={name:"AES-KW",length:r},o=["wrapKey","unwrapKey"];break;case "A128GCMKW":case "A192GCMKW":case "A256GCMKW":case "A128GCM":case "A192GCM":case "A256GCM":r=parseInt(e.slice(1,4),10),n={name:"AES-GCM",length:r},o=["encrypt","decrypt"];break;default:throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return crypto.subtle.generateKey(n,t?.extractable??false,o)}var ks="WebCryptoAPI";exports.CompactEncrypt=xe;exports.CompactSign=Pe;exports.EmbeddedJWK=Lr;exports.EncryptJWT=ft;exports.FlattenedEncrypt=G;exports.FlattenedSign=re;exports.GeneralEncrypt=it;exports.GeneralSign=pt;exports.SignJWT=dt;exports.UnsecuredJWT=lt;exports.base64url=Fe;exports.calculateJwkThumbprint=rr;exports.calculateJwkThumbprintUri=Nr;exports.compactDecrypt=nt;exports.compactVerify=at;exports.createLocalJWKSet=$e;exports.createRemoteJWKSet=Xr;exports.cryptoRuntime=ks;exports.customFetch=or;exports.decodeJwt=qr;exports.decodeProtectedHeader=Yr;exports.errors=St;exports.exportJWK=be;exports.exportPKCS8=Tr;exports.exportSPKI=Ir;exports.flattenedDecrypt=ge;exports.flattenedVerify=Ke;exports.generalDecrypt=Jr;exports.generalVerify=Rr;exports.generateKeyPair=Qr;exports.generateSecret=Zr;exports.importJWK=j;exports.importPKCS8=Kr;exports.importSPKI=gr;exports.importX509=br;exports.jwksCache=Ge;exports.jwtDecrypt=_r;exports.jwtVerify=kr;}));